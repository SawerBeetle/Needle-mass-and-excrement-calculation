---
title: "Дефолиация темнохвойных пород сибирским шелкопрядом и баланс углерода"
author: "Денис Демидко"
date: "2023-11-16"
output: word_document
bibliography: references.bib
---

# Вводная часть

Основная цель расчётов -- получить динамику выделения углерода в атмосферу при разложении экскрементов и огрызков хвои в очаге сибирского шелкопряда в пихтовых и кедровых древостоях. В качестве модельной территории выступает Западный Саян (междуречье рр. Кан и Агул). Исходные данные для моделирования -- таксационные описания древостоев на территории очагов.

## Моделирование массы хвои

Масса хвои зависит от ряда таксационных характеристик (ТХ) древостоя. При этом ТХ взаимодействуют друг с другом сложным образом [@usolcev2001; @semechkin2002], а связь их с массой хвои нередко нелинейна [@usolcev1985]. Это привело к отсутствию консенсуса о наилучшем способе расчёта массы хвои.Из этого следует, что такой способ придётся выбирать самостоятельно.

Здесь мы проверили три вида моделей. Первый -- линейная модель, для которой мы отыскиваем наилучший набор предикторов (далее *ЛМ*). Второй, который и моделью-то не назовёшь -- использование переводных коэффициентов (далее *ПК*) Д.Г. Замолодчикова с соавт. [@zamolodchikov2003]. Третий -- тоже переводные коэффициенты, но за авторством Д.Г. Щепащенко с соавт. [@schepaschenko2018].

```{r setup, include=FALSE}
# R Markdown options setting
knitr::opts_chunk$set(include = FALSE, echo = FALSE, warning = FALSE, message = FALSE)
```

```{r clear_env}
# clear environment before work 
rm(list=ls())
```

# Используемые библиотеки

Для регрессионного анализа: `lme4`. Для создания графиков: `ggplot2`, `cowplot`, `ggridges`. Для манипуляции данными: `readxl`, `tidyr`.

```{r libraries}
# load libraries
library(readxl)
library(lme4)
library(ggplot2)
library(ggridges)
library(cowplot)
library(tidyr)
```

```{r set_wd}
# set working directory
setwd('C:/Users/user/YandexDisk/Важные документы/Исходные данные для статей/Слинкиной/')
```

# Загрузка данных о массе хвои и ТХ, расчёт полнот {#загрузка-данных-о-массе-хвои-и-тх-расчёт-полнот}

Данные по ТХ и массе хвои взяты по [@usolcev2010] для южной тайги Алтае-Саянской горной провинции (исключение -- ель в Алтае-Саянской горной провинции, там есть данные только по лесостепи). Для кедра и ели добавлены данные для Забайкальской горной провинции, а для ели ещё и Уральской провинции (примечание см. ниже). Эти данные загружены из локальных файлов `.xlsx`. Данные об изменении количества стволов на га для модельных древостоев пихты (для Кузнецкого Алатау) взяты из [@kozlovskiy1967], кедра из [@semechkin2002] (таблица 46), ели из [@zagreev1992] (таблица 131), также из `.xlsx`.

По кедру вменяемых данных для Алтае-Саянской горной провинции не хватает. Нехилый их кусок (78--95) абсолютно лажово отражает реальность: масса хвои на промежутке 100...240 лет в нём практически не меняется. Поэтому он исключён, а вместо него взяты данные для Забайкальской горной провинции. Данные же по культурам кедра я вообще брать не пробовал. Кто его знает, насколько закономерности распределения фитомассы в них сходны с естественными древостоями.

По ели сибирской данных не хватает ещё сильнее. Для Алтае-Саянской провинции пробных площадей всего 15, ещё 3 для Забайкальской. Поэтому и пришлось добавлять Уральскую. Замечания по собранным в культурах данным, сделанные для кедра, верны и здесь.

```{r read_raw_data}
# Load raw data for model building and validation (Usoltsev, 2010) 
# from .csv files: fir, 
raw_as <- read_excel('Масса хвои пихты.xlsx')[, 2:7]
# stone pine,
raw_ps <- read_excel('Масса хвои кедра.xlsx')[, 2:7]
raw_ps <- raw_ps[c(1:9, 28:49), ]
# spruce. 
raw_pc <- read_excel('Масса хвои ели.xlsx')[, 2:7]

# Load data about relative stocks 
# (Kozlovskiy, Pavlov, 1967; Semechkin, 2002)
growth_table <- read_excel('growth_tables.xlsx')
```

```{r schep_coeffs}
# coefficients for Schepaschenko function by tree species
schep_coeffs <- data.frame(
  abies = c(4.2704, -1.3153, -0.6861, -0.0233, 0.0063, -0.3278), 
  stone_pine = c(8.8813, -2.1237, -0.9001, 0.3048, 0.0120, -1.6325), 
  picea = c(5.9899, -1.5668, -0.8115, 0.1443, 0.0084, -0.6000), 
  row.names = c('a0', 'a1', 'a2', 'a3', 'a4', 'a5')
)
# mean tree heights for tree species
si_heights <- data.frame(
  abies=c(36.25, 32.5, 28.8, 25.1, 21.4, 17.7, 14, 10.3, 6.2),
  stone_pine=c(41.4, 37.15, 32.95, 28.7, 24.45, 20.2, 15.95, 11.7, 7.45),
  row.names = c('Ib', 'Ia', 'I', 'II', 'III', 'IV', 'V', 'Va', 'Vb')
)
```

Для расчёта ПК по Щепащенко, однако, нужны полноты, которых у Усольцева нет. Поэтому в качестве приближения полноты рассчитываем отношение реального количества стволов с поправкой на долю изучаемой породы в древостое к эталонному, взятому из таблиц хода роста:

$$RS=\frac{(1-q)N_{real}+N_{real}}{N_{table}},$$

где $RS$ -- полнота (*relative stock* у Щепащенко), $N_{real}$ и $N_{table}$ -- объёмы стволов, соответственно, измеренные и табличные, $(1-q)N_{real}$ -- доля остальных пород в древостое по объёму стволов.

Для расчёта модельного (эталонного) количества стволов в зависимости от возраста мы используем в качестве основы таблицы хода роста [@kozlovskiy1967; @semechkin2002; @zagreev1992]. Моделируем логарифм количества стволов по логарифму возраста. Далее, чтобы получить модельное количество стволов нужно будет взять экспоненту от результата.

```{r model_stem_numbers_calc}
# Split the growth table by tree species and site indices. First, 
# create the list for species and give the appropriate names.
growth <- vector(mode='list', length=length(unique(growth_table$sp)))
names(growth) <- unique(growth_table$sp)
# Then split the data by species in outer loop ('i' counter): 
for(i in 1:length(growth)) {
  # create temporary df with data about ith species, 
  tmp <- subset(growth_table, sp == names(growth)[i])
  # create in ith element of 'growth' list the nested list for site indices and
  growth[[i]] <- vector(mode='list', length=length(unique(tmp$si)))
  names(growth[[i]]) <- (unique(tmp$si))
  # in the nested loop ('j' counter) split the data from 'tmp' by indices. 
  for(j in unique(tmp$si)) {
    # For this purpose we just subset the 'tmp' j times 
    # by jth site index code each time. 
    growth[[i]][[j]] <- subset(tmp, si == j)
  } 
  # delete the temporary df and counter
  rm(tmp, j)
} 
# delete growth table data and counter
rm(i, growth_table)
```

```{r n_stem_models}
# Create the Verhulst models for species and site indices. 
# First, create the list for models. 
n_models <- growth
# Then in the two nested loops create the models for each ith tree species
for(i in 1:length(growth)) {
  # and jth site index.
  for(j in 1:length(growth[[i]])) { 
    # hear is linear model of volume by age 
    n_models[[i]][[j]] <- lm(log(n) ~ log(age), growth[[i]][[j]])
    # print RSS of each model
    cat(
      'RSS для ',
      names(n_models)[i],
      names(n_models[[i]])[j],
      ' бонитета равно ',
      deviance(n_models[[i]][[j]]),
      sep=' ',
      fill=T
      )
  }
  # remove iterator
  rm(j)
}
# remove iterator and growth data
rm(i, growth)
```

```{r fir_rs_calc}
# calculate the relative stock for fir
# create the column for calculated relative stocks
raw_as$rs <- NA
for(i in 1:nrow(raw_as)) {
  # this is conditions for model selection by site index
  if(raw_as$site_index[i] %in% 
     c('Ib', 'ib', 'Iб', 'iб', 'Ia', 'ia', 'Iа', 'iа', 'I', 'i'))
    model <- n_models$fir$I
  if(raw_as$site_index[i] %in% c('II', 'ii'))
    model <- n_models$fir$II
  if(raw_as$site_index[i] %in% c('III', 'iii'))
    model <- n_models$fir$III
  if(raw_as$site_index[i] %in% c('IV', 'iv'))
    model <- n_models$fir$IV
  if(raw_as$site_index[i] %in% 
     c('Vb', 'Vb', 'vб', 'vб', 'Va', 'Va', 'vа', 'vа', 'V', 'v'))
    model <- n_models$fir$V
  # calculate the model number of fir stems per ha
  raw_as$rs[i] <- exp(predict(model, newdata=data.frame(age=raw_as$age[i])))
}
# remove counter and temporary objects from loop
rm(i, model)
# calculate relative stock for fir
raw_as$rs <- round(
  ((1 - raw_as$qouta)*raw_as$n_stem + raw_as$n_stem) / raw_as$rs, 
  digits = 2
  )
```

```{r stone_pine_rs_calc}
# calculate the relative stock for stone pine
# create the column for calculated relative stocks
raw_ps$rs <- NA
for(i in 1:nrow(raw_ps)) {
  # this is conditions for model selection by site index
  if(raw_ps$site_index[i] %in% 
     c('Ib', 'ib', 'Iб', 'iб', 'Ia', 'ia', 'Iа', 'iа', 'I', 'i'))
    model <- n_models$stone_pine$I
  if(raw_ps$site_index[i] %in% c('II', 'ii'))
    model <- n_models$stone_pine$II
  if(raw_ps$site_index[i] %in% c('III', 'iii'))
    model <- n_models$stone_pine$III
  if(raw_ps$site_index[i] %in% c('IV', 'iv'))
    model <- n_models$stone_pine$IV
  if(raw_ps$site_index[i] %in% c('V', 'v'))
    model <- n_models$stone_pine$V
  if(raw_ps$site_index[i] %in% 
     c('Vb', 'Vb', 'vб', 'vб', 'Va', 'Va', 'vа', 'vа'))
    model <- n_models$stone_pine$Va
  # calculate the model number of fir stems per ha
  raw_ps$rs[i] <- exp(predict(model, newdata=data.frame(age=raw_ps$age[i])))
}
# remove counter and temporary objects from loop
rm(i, model)
# calculate relative stock for fir
raw_ps$rs <- round(
  ((1 - raw_ps$quota)*raw_ps$n_stem + raw_ps$n_stem) / raw_ps$rs, 
  digits = 2
  )
```

```{r stone_pine_pc_calc}
# calculate the relative stock for spruce
# create the column for calculated relative stocks
raw_pc$rs <- NA
for(i in 1:nrow(raw_pc)) {
  # this is conditions for model selection by site index
  if(raw_pc$site_index[i] %in% c('Ib', 'ib', 'Iб', 'iб')) 
    model <- n_models$spruce$Iб
  if(raw_pc$site_index[i] %in% c('Ia', 'ia', 'Iа', 'iа')) 
    model <- n_models$spruce$Ia
  if(raw_pc$site_index[i] %in% c('I', 'i'))
    model <- n_models$spruce$I
  if(raw_pc$site_index[i] %in% c('II', 'ii'))
    model <- n_models$spruce$II
  if(raw_pc$site_index[i] %in% c('III', 'iii'))
    model <- n_models$spruce$III
  if(raw_pc$site_index[i] %in% c('IV', 'iv'))
    model <- n_models$spruce$IV
  if(raw_pc$site_index[i] %in% c('V', 'v'))
    model <- n_models$spruce$V
  if(raw_pc$site_index[i] %in% 
     c('Vb', 'Vb', 'vб', 'vб', 'Va', 'Va', 'vа', 'vа'))
    model <- n_models$spruce$Va
  # calculate the model number of fir stems per ha
  raw_pc$rs[i] <- exp(predict(model, newdata=data.frame(age=raw_pc$age[i])))
}
# remove counter and temporary objects from loop
rm(i, model)
# calculate relative stock for fir
raw_pc$rs <- round(
  ((1 - raw_pc$quota)*raw_pc$n_stem + raw_pc$n_stem) / raw_pc$rs, 
  digits = 2
  )
```

```{r df_for_results}
# Before needle mass calculation, let's create the dfs for results: 
# fir, 
res_as <- data.frame(
  lm = rep(NA, nrow(raw_as)), 
  lm_resid = rep(NA, nrow(raw_as)), 
  cfz = rep(NA, nrow(raw_as)), 
  cfz_resid = rep(NA, nrow(raw_as)),
  cfs = rep(NA, nrow(raw_as)), 
  cfs_resid = rep(NA, nrow(raw_as))
)
# stone pine, 
res_ps <- data.frame(
  lm = rep(NA, nrow(raw_ps)), 
  lm_resid = rep(NA, nrow(raw_ps)), 
  cfz = rep(NA, nrow(raw_ps)), 
  cfz_resid = rep(NA, nrow(raw_ps)),
  cfs = rep(NA, nrow(raw_ps)), 
  cfs_resid = rep(NA, nrow(raw_ps))
)
# spruce 
res_pc <- data.frame(
  lm = rep(NA, nrow(raw_pc)), 
  lm_resid = rep(NA, nrow(raw_pc)), 
  cfz = rep(NA, nrow(raw_pc)), 
  cfz_resid = rep(NA, nrow(raw_pc)),
  cfs = rep(NA, nrow(raw_pc)), 
  cfs_resid = rep(NA, nrow(raw_pc))
)
```

# Поиск наилучших моделей

Общий план оценки моделей:

-   смещённость результатов (оценить относительно как среднего, так и медианы);
-   разброс результатов;
-   симметричность распределения;
-   связь остатков с предикторами.

Дополнительно рассчитывали корреляцию предсказанных значений с реальными. С гетероскедастичностью остатков я решил не работать: в принципе, есть основания полагать, что она и должна иметь место, а для моделирования эмиссии углерода нам достаточно, чтобы результаты были несмещёнными.

```{r fun_pred_vs_model_plot}
# Create a function 'predicted_plot' for plotting 
# data vector vs vector
# (useful both for Abies and for Pinus). 
predicted_plot <- function(
  # Arguments are:
  # dependend variable or predictor,
  real, 
  # model-calculated data or residuals, 
  predicted, 
  # title (string object) and 
  title, 
  # x-label (string object), 
  xlab,
  # y-label (string object). 
  ylab
) {
  # place the functions in 'tryCatch' handler for possible mistakes
  tryCatch(
    {
      # First, create a data frame for plotting 
      # (age, table data, model-based data). 
      frame <- data.frame(real, predicted) 
      # Create ggplot2-based plot:
      # in 'ggplot' create plot backbone from age and table (real) data,
      plot <- ggplot(frame, aes(x=real, y=predicted)) + 
        # add points (black colour), 
        geom_point() + 
        # add title (e.g., feature name and site index),
        labs(title = title) +
        # add x-label,
        xlab(xlab) + 
        # add y-label from argument and
        ylab(ylab) + 
        # set the colour theme.
        theme_bw()
      # output the plot to display
      return(plot)
    }, 
    # If the main block of function give us some error, 
    # suppress the error message and print brief string. 
    error = function(e) {
      message('Кидает error, проверяйте данные')
    },
    # If the main block of function give us some warning, 
    # suppress the warning message and print brief string. 
    warning = function(w) {
      message('Кидает warning, проверяйте данные')
    }
  )
}
```

```{r fun_jointed_plot}
# Function 'joined_plot' for jointed plot. Arguments:
# data – data frame with stand features and needle masses, 
# predicted – column with needle masses predicted by model, 
# results – data frame with results of modelling, 
# residuals – column with with residuals. 
joined_plot <- function(data, predicted, results, residuals) {
  # real needle masses vs predicted
  plot_real_vs_model <- predicted_plot(
  data$needle_mass, 
  predicted, 
  'Реальные и модельные массы хвои', 
  'Реальные данные', 
  'Данные модели'
  ) + geom_abline(slope=1)
  # real needle masses vs residuals, 
  plot_real_vs_resid <- predicted_plot(
    data$needle_mass, 
    residuals, 
    'Зависимость остатков от массы хвои', 
    'Масса хвои', 
    'Остатки'
    ) + geom_hline(yintercept=0)
  # ages vs residuals, 
  plot_age_vs_resid <- predicted_plot(
    data$age, 
    residuals, 
    'Зависимость остатков от возраста', 
    'Возраст', 
    'Остатки'
    ) + geom_hline(yintercept=0)
  # volumes vs residuals,
  plot_vol_vs_resid <- predicted_plot(
    data$volume, 
    residuals, 
    'Зависимость остатков от объёма стволов', 
    'Объём стволов', 
    'Остатки'
    ) + geom_hline(yintercept=0)
  # relative stocks vs residuals,
  plot_rs_vs_resid <- predicted_plot(
    data$rs, 
    residuals, 
    'Зависимость остатков от полноты древостоя', 
    'Полноты', 
    'Остатки'
    ) + geom_hline(yintercept=0)
  # density of residuals.
  plot_dens <- ggplot(results, aes(residuals)) + 
    geom_density() + 
    geom_rug() + 
    labs(title = 'Распределение остатков') + 
    xlab(element_blank()) + 
    ylab('Плотность вероятности') + 
    theme_bw()
  
  # create jointed plot for all dependencies
  joined <- plot_grid(
    plot_real_vs_model, plot_dens,
    plot_real_vs_resid, plot_age_vs_resid,
    plot_rs_vs_resid, plot_vol_vs_resid,
    ncol=2
    )
  return(joined)
}
```

```{r fun_summary_table}
# Create the function to calculate the basic statistics of residuals 
# and create box plots when different methods use. 
basic_stats <- function(res) {
  knitr::kable(
    data.frame(
      LM = round(as.vector(summary(res$lm_resid)), digits=2)[1:6], 
      CFZ = round(as.vector(summary(res$cfz_resid)), digits=2)[1:6], 
      CFS = round(as.vector(summary(res$cfs_resid)), digits=2)[1:6],
      row.names = names(summary(res$lm_resid))[1:6]
    ), 
    caption=('Описательные статистики для остатков')
  )
}
```

```{r fun_correlations}
# Create the function for make table with correlation coefficients
# between real and predicted data when different methods use
correlations <- function(raw, res) {
  knitr::kable(
    data.frame(
      LM = c(
        round(
          cor.test(
            raw$needle_mass, 
            res$lm, 
            method = 'spearman')$estimate, 
          digits=3
        ),
        round(
          cor.test(
            raw$needle_mass, 
            res$lm, 
            method = 'spearman')$p.value, 
          digits=3
        )
      ),
      CFZ = c(
        round(
          cor.test(
            raw$needle_mass, 
            res$cfz, 
            method = 'spearman')$estimate, 
          digits=3
        ),
        round(
          cor.test(
            raw$needle_mass, 
            res$cfz, 
            method = 'spearman')$p.value, 
          digits=3
        )
      ),
      CFS = c(
        round(
          cor.test(
            raw$needle_mass, 
            res$cfs, 
            method = 'spearman')$estimate, 
          digits=3
        ),
        round(
          cor.test(
            raw$needle_mass, 
            res$cfs, 
            method = 'spearman')$p.value, 
          digits=3
        )
      ), 
      row.names = c('spearman rho', 'p value')
    )
  )
}
```

```{r fun_densities}
densities_plot <- function(forplot) {
  # Create a ggridge plot. First, the backbone.
  dplot <- ggplot(forplot, aes(x=value, y=name, fill=factor(stat(quantile)))) + 
    # Second, the geom with coloured tales:
    stat_density_ridges(
      # add the geom, 
      geom='density_ridges_gradient', 
      # add the data points and 
      jittered_points=T, 
      # give them the rug shape (vertical line), 
      point_shape='|', 
      # choose the size of points, 
      point_size=3, 
      # put the points to y-axis, 
      position = position_points_jitter(height = 0), 
      # add the quantile lines (median and 5%), 
      quantile_lines=T, 
      quantiles=c(0.05, 0.5, 0.95),
      # choose the size of density polygons (to avoid the overlap) and 
      scale=0.9, 
      # suppress legend. 
      show.legend = F
    ) + 
    # choose the colour of tails
    scale_fill_manual(
      name = "Probability", 
      values = c("lightpink1", "gray95", "gray95", "lightblue1"),
    ) + 
    # give the axes names
    ylab('Метод') + 
    xlab('Величина остатка') + 
    # choose the colour theme
    theme_bw()
  
  return(dplot)
}
```

## *ЛМ*

Модели с фиксированными эффектами (mixed-effect models) строили на данных для реальных пробных площадей из [@usolcev2010] для Алтае-Саянской горной провинции с помощью функции `lmer` из пакета `lme4` [@lme4]. В качестве предикторов проверяли возраст, объём и бонитет, учитывая их взаимодействие.

Использовать линейные модели не стоит, какими бы хорошими они не выглядели. Во-первых, к данным из @usolcev2010] есть вопросы (см. [Загрузка данных о массе хвои и ТХ, расчёт полнот](#загрузка-данных-о-массе-хвои-и-тх-расчёт-полнот)). Во-вторых, за такое заклюют при рецензировании -- хотя бы из-за предполагаемой их переобученности. Однако как эталон для сравнения с ними других результатов линейные модели показать стоит.

### Пихта

```{r abies_linear_model, include=TRUE, fig.height=7.5, fig.width=7.5}
# create linear model (take into account the interaction between predictors)
model_lm_as <- lmer(
  needle_mass ~ age + volume + (age|site_index) + (volume|site_index), 
  raw_as
) 

# Put into results df 'res_as' the predicted needle masses and
res_as$lm <- predict(model_lm_as)
# residuals. 
res_as$lm_resid <- res_as$lm - raw_as$needle_mass

# coefficients of linear model and their characteristics
knitr::kable(
  round(data.frame(coef(model_lm_as)[[1]]), digits=3),
  caption = ('Коэффициенты линейной модели')
  )

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_as, res_as$lm, res_as, res_as$lm_resid)
```

### Кедр

```{r psib_linear_model, include=TRUE, fig.height=7.5, fig.width=7.5}
model_lm_ps <- lmer(
  needle_mass ~ age + volume + (age|site_index) + (volume|site_index),
  raw_ps
)

# Put into results df 'res_as' the predicted needle masses and
res_ps$lm <- predict(model_lm_ps)
# residuals. 
res_ps$lm_resid <- res_ps$lm - raw_ps$needle_mass

# coefficients of linear model and their characteristics
knitr::kable(
  round(data.frame(coef(model_lm_ps)[[1]]), digits=3),
  caption = ('Коэффициенты линейной модели')
  )

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_ps, res_ps$lm, res_ps, res_ps$lm_resid)
```

### Ель

```{r picea_linear_model, include=TRUE, fig.height=7.5, fig.width=7.5}
model_lm_pc <- lmer(
  needle_mass ~ age + volume + (age|site_index) + (volume|site_index),
  raw_pc
)

# Put into results df 'res_as' the predicted needle masses and
res_pc$lm <- predict(model_lm_pc)
# residuals. 
res_pc$lm_resid <- res_pc$lm - raw_pc$needle_mass

# coefficients of linear model and their characteristics
knitr::kable(
  round(data.frame(coef(model_lm_pc)[[1]]), digits=3),
  caption = ('Коэффициенты линейной модели')
  )

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_pc, res_pc$lm, res_pc, res_pc$lm_resid)
```

## *ПК по Замолодчикову*

Способ для ленивых. Умножаем объём стволовой древесины на переводной коэффициент, взятый из [@zamolodchikov2003], проверяем по данным из [@usolcev2010].

**N.B.:** коэффициент 0.138 для молодняков пихты произвольно уменьшен мной вдвое, иначе результаты получаются безобразно завышенными.

### Пихта

```{r abies_cf_zam, include=TRUE, fig.height=7.5, fig.width=7.5}
# In the loop calculate the needle masses by age-related conversion factors: 
for(i in 1:nrow(raw_as)) {
  # for young stands (I have included coef 0.5 arbitrary 
  # for prevent large bias; the method give very imprecise result 
  # if age <= 40), 
  if(raw_as$age[i] <= 40) res_as$cfz[i] <- .5 * .138 * raw_as$volume[i] 
  # for middle-aged stands, 
  if(raw_as$age[i]>40 & raw_as$age[i]<=60) 
    res_as$cfz[i] <- .047 * raw_as$volume[i]
  # for premature stands and
  if(raw_as$age[i]>60 & raw_as$age[i]<=80) 
    res_as$cfz[i] <- .037 * raw_as$volume[i]
  # for mature stands.
  if(raw_as$age[i] > 80) res_as$cfz[i] <- .035 * raw_as$volume[i]
}
# remove counter
rm(i)

# calculate residuals
res_as$cfz_resid <- res_as$cfz - raw_as$needle_mass

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_as, res_as$cfz, res_as, res_as$cfz_resid)
```

### Кедр

```{r psib_cf_zam, include=TRUE, fig.height=7.5, fig.width=7.5}
# In the loop calculate the needle masses by age-related conversion factors: 
for(i in 1:nrow(raw_ps)) {
  # for young stands, 
  if(raw_ps$age[i] <= 80) res_ps$cfz[i] <- .068 * raw_ps$volume[i]
  # for middle-aged stands, 
  if(raw_ps$age[i]>80 & raw_ps$age[i]<=120) res_ps$cfz[i] <- .027 * raw_ps$volume[i]
  # for premature stands and
  if(raw_ps$age[i]>120 & raw_ps$age[i]<=160) res_ps$cfz[i] <- .027 * raw_ps$volume[i]
  # for mature stands.
  if(raw_ps$age[i] > 160) res_ps$cfz[i] <- .045 * raw_ps$volume[i]
}
# remove counter
rm(i)

# calculate residuals
res_ps$cfz_resid <- res_ps$cfz - raw_ps$needle_mass

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_ps, res_ps$cfz, res_ps, res_ps$cfz_resid)
```

### Ель

```{r picea_cf_zam, include=TRUE, fig.height=7.5, fig.width=7.5}
# In the loop calculate the needle masses by age-related conversion factors: 
for(i in 1:nrow(raw_pc)) {
  # for young stands, 
  if(raw_pc$age[i] <= 40) res_pc$cfz[i] <- .258 * raw_pc$volume[i]
  # for middle-aged stands, 
  if(raw_pc$age[i]>40 & raw_pc$age[i]<=60) res_pc$cfz[i] <- .056 * raw_pc$volume[i]
  # for premature stands and
  if(raw_pc$age[i]>60 & raw_pc$age[i]<=80) res_pc$cfz[i] <- .043 * raw_pc$volume[i]
  # for mature stands.
  if(raw_pc$age[i] > 80) res_pc$cfz[i] <- .042 * raw_pc$volume[i]
}
# remove counter
rm(i)

# calculate residuals
res_pc$cfz_resid <- res_pc$cfz - raw_pc$needle_mass

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_pc, res_pc$cfz, res_pc, res_pc$cfz_resid)
```

## *ПК по Щепащенко*

Умножаем объёмы стволовой древесины на переводные коэффициенты, рассчитанные по [@schepaschenko2018], проверяем по данным из [@usolcev2010].

**N.B.:** нужно учитывать, что полноты, использованные при расчёте переводных коэффициентов, не реальные, а также рассчитанные. А к результатам регрессии, по которой этот я расчёт проводил, тоже есть претензии. Так что это дополнительно добавляет неточности в полученные результаты.

### Пихта

```{r abies_cf_schep, include=TRUE, fig.height=7.5, fig.width=7.5}
# In the loop calculate the needle masses by Schepaschenko conversion factors
# in logit form: 
for(i in 1:nrow(raw_as)) {
  si_height <- 
    si_heights[match(raw_as[i, "site_index"], row.names(si_heights)), 'abies']
  # calculate the conversion factors
  res_as$cfs[i] <- schep_coeffs['a0', 'abies'] + 
    schep_coeffs['a1', 'abies']*log(raw_as$age[i]) + 
    schep_coeffs['a2', 'abies']*log(si_height) + 
    schep_coeffs['a3', 'abies']*log(raw_as$rs[i]) + 
    schep_coeffs['a4', 'abies']*raw_as$age[i] + 
    schep_coeffs['a5', 'abies']*raw_as$rs[i]
}
# remove counter and temporary variable
rm(i, si_height)

# calculate the true values of Schepaschenko conversion factors
res_as$cfs <- exp(res_as$cfs)/(1-exp(res_as$cfs))

# calculate the needle masses by Schepaschenko method
res_as$cfs <- res_as$cfs * raw_as$volume

# calculate residuals
res_as$cfs_resid <- res_as$cfs - raw_as$needle_mass

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_as, res_as$cfs, res_as, res_as$cfs_resid)
```

### Кедр

```{r psib_cf_schep, include=TRUE, fig.height=7.5, fig.width=7.5}
# In the loop calculate the needle masses by Schepaschenko conversion factors
# in logit form: 
for(i in 1:nrow(raw_ps)) {
  si_height <- 
    si_heights[match(
      raw_ps[i, "site_index"], row.names(si_heights)
      ), 'stone_pine']
  # calculate the conversion factors
  res_ps$cfs[i] <- schep_coeffs['a0', 'stone_pine'] + 
    schep_coeffs['a1', 'stone_pine']*log(raw_ps$age[i]) + 
    schep_coeffs['a2', 'stone_pine']*log(si_height) + 
    schep_coeffs['a3', 'stone_pine']*log(raw_ps$rs[i]) + 
    schep_coeffs['a4', 'stone_pine']*raw_ps$age[i] + 
    schep_coeffs['a5', 'stone_pine']*raw_ps$rs[i]
}
# remove counter and temporary variable
rm(i, si_height)

# calculate the true values of Schepaschenko conversion factors
res_ps$cfs <- exp(res_ps$cfs)/(1-exp(res_ps$cfs))

# calculate the needle masses by Schepaschenko method
res_ps$cfs <- res_ps$cfs * raw_ps$volume

# calculate residuals
res_ps$cfs_resid <- res_ps$cfs - raw_ps$needle_mass

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_ps, res_ps$cfs, res_ps, res_ps$cfs_resid)
```

### Ель

```{r picea_cf_schep, include=TRUE, fig.height=7.5, fig.width=7.5}
# In the loop calculate the needle masses by Schepaschenko conversion factors
# in logit form: 
for(i in 1:nrow(raw_pc)) {
  si_height <- 
    si_heights[match(raw_pc[i, "site_index"], row.names(si_heights)), 'abies']
  # calculate the conversion factors
  res_pc$cfs[i] <- schep_coeffs['a0', 'picea'] + 
    schep_coeffs['a1', 'picea']*log(raw_pc$age[i]) + 
    schep_coeffs['a2', 'picea']*log(si_height) + 
    schep_coeffs['a3', 'picea']*log(raw_pc$rs[i]) + 
    schep_coeffs['a4', 'picea']*raw_pc$age[i] + 
    schep_coeffs['a5', 'picea']*raw_pc$rs[i]
}
# remove counter and temporary variable
rm(i, si_height)

# calculate the true values of Schepaschenko conversion factors
res_pc$cfs <- exp(res_pc$cfs)/(1-exp(res_pc$cfs))

# calculate the needle masses by Schepaschenko method
res_pc$cfs <- res_pc$cfs * raw_pc$volume

# calculate residuals
res_pc$cfs_resid <- res_pc$cfs - raw_pc$needle_mass

# Then show dependencies between predicted and real data or 
# between variables and residuals:
# real and model-based Abies needle masses, 
joined_plot(raw_pc, res_pc$cfs, res_pc, res_pc$cfs_resid)
```

## Резюме по выбору модели

### Пихта

Результаты по Щепащенко менее смещены и относительно компактны. Хотя в обе стороны от центра выбрасываются длинные хвосты, это компенсируется симметричностью распределения: хотя для отдельных древостоев ошибки могут быть значительны, результат моделирования для очага в целом будет близок к истинному.

Расчёты по Щепащенко показывают тенденцию к завышению при низких значениях полнот, объёмов стволов и масс хвои. Но на фоне методики Замолодчикова они всё равно смотрятся выгоднее, так как она показывает завышение во всём спектре ТХ (и это я ещё и один из коэффициентов поменял, чтобы завышение не было настолько сильным!).

Корреляции предсказанных значений $m_f$ с реальными довольно тесны и значимы статистически для всех проверенных методов расчёта.

**Резюме:** методика Щепащенко.

```{r  abies_resid_comparison, include=TRUE, fig.height=5, fig.width=5}
# create the table with basic descriptive stats for LM, CFZ and CFS
basic_stats(res_as)
# Add ggridges plot with the same data. First, create df, 
forplot <- res_as[, c(2, 4, 6)]
# give the appropriate names of columns and 
colnames(forplot) <- c('LM', 'CFZ', 'CFS') 
# make the long form of data frame. 
forplot <- pivot_longer(forplot, cols = 1:3)
# create a joined density plot
densities_plot(forplot)
# remove the temporary df
rm(forplot)
# create the table with correlation coefficients
correlations(raw_as, res_as)
```

### Кедр

Результаты по Замолодчикову смещены вправо (завышены), по Щепащенко -- влево. При этом первая методика показывает дикий межквартильный размах и длинный хвост вправо. При выборе методики Замолодчикова мы гарантированно получаем завышение для объёмов стволовой древесины более 150 $м^3 га^{-1}$ и возрасте более 100 лет. Соответственно, по Щепащенко мы результаты примерно при этих же границах, а также при высоких реальных массах хвои, занизим, но не настолько сильно. На более тесную корреляцию реальных и предсказанных результатов по Замолодчикову обращать внимание не стоит: эта связь обусловлена диким завышением расчётных значений при увеличении возраста и запаса.

**Резюме:** методика Щепащенко.

```{r psib_resid_comparison, include=TRUE, fig.height=5, fig.width=5}
# create the table with basic descriptive stats for LM, CFZ and CFS
basic_stats(res_ps)
# create the table with correlaton coefficients
forplot <- res_ps[, c(2, 4, 6)]
# give the appropriate names of columns and 
colnames(forplot) <- c('LM', 'CFZ', 'CFS') 
# make the long form of data frame. 
forplot <- pivot_longer(forplot, cols = 1:3)
# create a joined density plot
densities_plot(forplot)
# remove the temporary df
rm(forplot)
correlations(raw_ps, res_ps)
# Add ggridges plot with the same data. First, create df, 
```

### Ель

Расчётные показатели по Щепащенко несколько завышены, но не так, как по Замолодчикову. В пользу Замолодчикова говорит более компактное распределение остатков (а у Щепащенко оно, к тому же, бимодально). Однако, выбор метода Замолодчикова приведёт к появлению значительно завышенных результатов: длинный хвост вправо на графике бросается в глаза. Для обеих методик очевидно завышение при низких значениях $m_f$ и ТХ и занижение при высоких. Более же тесная корреляция расчётных и реальных величин $m_f$ по Замолодчикову -- слабый аргумент в пользу применения его метода: в конечном счёте важнее не точность прогноза по отдельным древостоям, а адекватный результат для всего очага.

**Резюме:** всё же методика Щепащенко. Здесь она выглядит не настолько выигрышно, но для единообразия использованных в работе подходов лучше остановиться на ней. Выгода очевидна, а потеря в точности, если и будет, то небольшой.

```{r  picea_resid_comparison, include=TRUE, fig.height=5, fig.width=5}
# create the table with basic descriptive stats for LM, CFZ and CFS
basic_stats(res_pc)
# create the table with correlaton coefficients
forplot <- res_pc[, c(2, 4, 6)]
# give the appropriate names of columns and 
colnames(forplot) <- c('LM', 'CFZ', 'CFS') 
# make the long form of data frame. 
forplot <- pivot_longer(forplot, cols = 1:3)
# create a joined density plot
densities_plot(forplot)
# remove the temporary df
rm(forplot)
correlations(raw_pc, res_pc)
# Add ggridges plot with the same data. First, create df, 
```

# Фракции хвои в очаге сибиряка {#фракции-хвои-в-очаге-сибиряка}

В общем виде хвоя кормовых пород сибирского шелкопряда в его очагах делится на следующие фракции:

-   усвоенная гусеницами и использованная для роста (assimilated, *assim*),
-   усвоенная гусеницами и использованная для обеспечения энергетических потребностей (metabolized, *met*),
-   попавшая в опад в виде огрызков (*stub*),
-   то же, в виде экскрементов (excrement, *excr*),
-   несъеденная (remaining, *rem*).

Для учёта доли *rem* в общей массе хвои достаточно ввести поправочный коэффициент, и на этом я здесь вообще останавливаться не буду. Далее я исхожу из 100% дефолиации, при которой нужно распределить массу хвои между оставшимися фракциями.

В опад (litterfall, *litt*) уходят *stub* и *excr*.

В [@kirichenko2008], приведены уравнения регрессии, описывающие зависимость массы тела гусениц от массы изъятого корма (affected, *aff*), которая складывается из *assim*, *met*, *ecxr* и *stub*. Из коэффициентов при *x* следует, что доля усвоенного гусеницами корма (*assim* + *met*) составляет 24,3% от изъятого для пихты, 21,5% для кедра и 15,5% для ели. Иначе говоря, для пихты $m_{litt} = 0,757m_f$, для кедра $m_{litt} = 0,785m_f$, для ели $m_{litt} = 0,845m_f$.

| На всякий случай опишу здесь ситуацию со *stub*. В обессмертившей имя Ю.Н. Баранчикова однопиське [@baranchikov1987] прямо указано, что [в природе]{.underline} гусеницы сибиряка роняют в виде огрызков 17% от *excr* вне зависимости от степени дефолиации. Результаты получены для лиственницы, но можно ввести поправку на основе данных из [@kirichenko2008] (Таблица 1). Расчёты на основании этой таблицы показывают, что хвои пихты в огрызки уходит 24,6% и кедра -- 22,9% от *excr* (для ели лень считать, но будет надо -- сделаю). Ещё раз: это в природе. Что [@baranchikov1987], что [@kirichenko2008] показывают, что в лаборатории доля огрызков относительно экскрементов может отличаться.

Усвоенный корм большей частью расходуется для обеспечения метаболизма, т. е., относится к фракции *met*. По данным [@baranchikov2002], туда относится 91,6% от массы усвоенной хвои. Оставшееся идёт на наращивание биомассы гусениц и большей частью выносится за пределы биогеоценоза. *Что-то, конечно, остаётся, но моделировать это сложно, а данных для получения корректных результатов недостаточно. Так что лучше не трогать, чтоб не побили.*

# Динамика разложения зоогенного опада

Судьба углерода, содержащегося в изъятой шелкопрядом хвое, различается [@krasnoshchyokov2003; @krasnoshchyokov2008]: "*Часть поступивших элементов усваивается растительностью, животными и микроорганизмами, часть ... выносится поверхностным жидким стоком, а часть проникает в нижние почвенные горизонты, закрепляется здесь или выносится ... за пределы этих ландшафтов*".

То, что усвоено микроорганизмами -- это и есть эмиссия углерода $E_C$. Всё это улетит в атмосферу в результате дыхания. То же касается доли, усвоенной растениями: этому углероду нужно сначала попасть в атмосферу, напрямую из почвы в растения поступает ничтожная доля органики. По-хорошему, это надо учитывать отдельно, но такие расчёты сильно усложняют модель, и я предлагаю от них отказаться. В некоторой (неясно, правда, какой) степени углерод, зафиксированный травянистым ярусом, уравновешивается углеродом, ушедшим в атмосферу с разложившейся подстилкой. А подстилка разлагается если не полностью, то в значительной части: через 4--5 лет после дефолиации из 5 см остаётся 1--1,5 см, а где-то нет и этого [@krasnoshchyokov2003]. И этот процесс следовало бы включить в модель, но без дополнительных экспериментов это невозможно.

Доля углерода, вынесенная с поверхностным стоком, известна из [@krasnoshchyokov2003; @krasnoshchyokov2008]. Её также не следует включать в эмиссию. Скорее всего, она депонируется в почве [@krasnoshchyokov2003] за пределами того участка, где она попала в воду, а если какая-то часть углерода и попадёт в атмосферу, то неизвестно, какая именно. Вынос углерода в водорастворимой форме составляет 3,7% [@krasnoshchyokov2008]. Для простоты считаем, что это значение не меняется на протяжении всего времени разложения *litt*.

В почве в пределах этого же участка депонируется часть растворённого углерода [@krasnoshchyokov2003] и, в форме копролитов, основная масса того, что усвоили животные. Но оценить её проблемно: данные о вкладе почвенных беспозвоночных в разложение *litt* отсутствуют. Ближе всего по свойствам к *litt*, очевидно, хвоя, но именно по хвое пихте и кедра таких данных, опять же, нет. В качестве грубого приближения можно использовать усреднённые данные о вкладе почвенной фауны в разложение хвои других хвойных. Эта величина составляет 23,8% [@bezkorovaynaya2011]. Это значение также считаем постоянным. *Ну, да, грубое упрощение. А куда деваться при условии отсутствия нормальных экспериментальных данных?* В сумме же имеем 27,5% углерода (вынос с почвенным стоком и образование копролитов), который так или иначе депонируется.

Разложение зоогенного опада в очагах сибиряка завершается на втором году после дефолиации. Маркером этого служит снижение различий почти до нуля по скорости разложения целлюлозы между экспериментальными участками, куда вносились экскременты, и контрольными, через 14 месяцев (т.е., как раз на второй год после внесения опада) [@krasnoshchyokov2003]. Это же прямым текстом указано в цитируемой работе: "*...период действия экскрементов гусениц сибирского шелкопряда на почвенную микрофлору ... составляет два, максимум три вегетационных сезона*".

В эксперименте, описанном в [@krasnoshchyokov2003; @krasnoshchyokov2008], в середине лета было внесено 450 г экскрементов на $м^{2}$ почвы, что составило 2092 кг углерода $га^{-1}$ (переводной коэффициент массы *litt* в углерод равен 0,465) [@krasnoshchyokov2003]. Уже весной следующего года от внесённого углерода осталось 437 кг $га^{-1}$. Это соответствует 940 кг *litt* $га^{-1}$ или 20,9% от исходной массы. Разумно предположить (опять же, несколько упрощая), что к началу следующего (третьего по счёту) вегетационного периода сохранится такая же доля от исходной массы, то есть, 196 кг опада $га^{-1}$. К концу сезона это количество разложится полностью (см. выше).

В итоге после учёта всех допущений имеем в самом простом виде такую формулу расчёта эмиссии углерода по массе зоогенного опада:

$$E_C = 0,465 * (m_{litt} - 0,275 * m_{litt}) = 0,337 * m_{litt}.$$ При этом в сезон дефолиации разлагается 79,1% от исходной массы $m_{litt}$, на следующий год 16,5%, а на второй год после дефолиации завершается разложение оставшихся 4,4%.

# Главная всеконечная формула

Забегая вперёд: одной формулы не получится, даже для одной породы. Общая последовательность такая:

1.  Рассчитываем массу хвои на гектар древостоя по методу Щепащенко с соавт. [@schepaschenko2018]. Сначала вычисляем логит переводного коэффициента:

    $$
    logit(BCEF)=a_0 + a_1log(A) + a_2log(SI) + a_3log(RS) + a_4A + a_5RS,
    $$

    где *BCEF* -- переводной коэффициент, *A* -- возраст древостоя, *SI* (*site index*) -- средняя высота дерева при данном бонитете в базовом возрасте (для ели и пихты 100 лет, для кедра 160 лет; высоты см. в таблице), *RS* (*relative stock*) -- полнота в долях единицы, $a_0...a_5$ -- коэффициенты (см. таблицу). Основание логарифма равно числу Эйлера (2,71...).

    | Бонитет | Пихта, ель | Кедр  |
    |---------|------------|-------|
    | Iб      | 36,25      | 41,40 |
    | Iа      | 32,50      | 37,15 |
    | I       | 28,80      | 32,95 |
    | II      | 25,10      | 28,70 |
    | III     | 21,40      | 24,45 |
    | IV      | 17,70      | 20,20 |
    | V       | 14,00      | 15,95 |
    | Vа      | 10,30      | 11,70 |
    | Vб      | 6.20       | 7,45  |

    : Высоты для разных бонитетов

    | Коэффициенты | Пихта   | Кедр    | Ель     |
    |--------------|---------|---------|---------|
    | $a_0$        | 4,2704  | 8,8813  | 5,9899  |
    | $a_1$        | -1,1353 | -2,1237 | -1,5668 |
    | $a_2$        | -0,6861 | -0,9001 | -0,8115 |
    | $a_3$        | -0,0233 | 0,3048  | 0,1443  |
    | $a_4$        | 0,0063  | 0,0120  | 0,0084  |
    | $a_5$        | -0,3278 | -1,6325 | -0,6000 |

    : Коэффициенты для расчёта BCEF

    На следующем этапе расчётов вычисляем собственно переводной коэффициент:

    $$
    BCEF = \frac{e^{logit(BCEF)}}{1-e^{logit(BCEF)}}.
    $$

    И уже с помощью этого коэффициента мы получаем массу хвои на гектар:

    $$
    m_f = BCEF*V,
    $$

    где *V* -- запас древостоя на гектар.

2.  Массу хвои умножаем на степень дефолиации, чтобы узнать массу изъятой хвои:

    $$
    m_{aff}=defol*m_f.
    $$

3.  Эту массу умножаем на зависящий от породы коэффициент [@kirichenko2008], чтобы получить массу зоогенного опада $m_{litt}$ (см. [Фракции хвои в очаге сибиряка](#фракции-хвои-в-очаге-сибиряка)).

4.  Массу зоогенного опада умножаем на переводной коэффициент [@krasnoshchyokov2003; @krasnoshchyokov2008; @bezkorovaynaya2011], чтобы получить массу эмитированного из него углерода:

    $$
    E_C=0,337m_{litt}.
    $$

5.  Разбиваем эмиссию по годам [@krasnoshchyokov2003; @krasnoshchyokov2008] ($E_{C1}$ -- сезон дефолиации и т.д.):

    $$E_{C1} = 0.791E_C$$ $$E_{C2} = 0.165E_C$$ $$E_{C3} = 0.044E_C$$

# Использованные источники
